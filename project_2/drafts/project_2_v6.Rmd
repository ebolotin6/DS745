---
title: "Project 2"
author: "Eli (Ilya) Bolotin"
date: "10/21/2019"
output: word_document
fontsize: 11
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
# Load libraries
if (!require("pacman")) install.packages("pacman")
pacman::p_load(statnet, devtools, UserNetR, igraphdata, maps, igraph, intergraph, network, sna, ggplot2, ggnet, plyr)
```

# Visualization and Network Summary

## Load data and view summary
```{r}
data(USairports)
summary(USairports)
full_net <- USairports
```

The network contains 23.5k edges, 755 nodes, 3 vertex attributes and 5 edge attributes. Due to the fact there are multiple edges and loops, it makes sense to simplify our network by eliminating multiple edges for the purposes of visualization.

## Simplify network and convert to statnet
```{r}
# simplify network
net1 <- simplify(full_net)
summary(net1)
detach(package:igraph)

# convert to statnet network
df <- asDF(net1)
net1 <- asNetwork(df$edges, vertices=df$vertexes)
```

## Analyze network
```{r}
# summary overall of network
# summary(net1)

# view vertex attributes
list.vertex.attributes(net1)

# view edge attributes
list.edge.attributes(net1)

# examine city vertex
head(get.vertex.attribute(net1, "City"))

# view density of network
density.n1 <- gden(net1)
```

Network density is `density.n1`. The closer to 1 the density is, "the more interconnected the network" [1] (p.14, class text). In the context of this data, density is small because of the hub-and-spoke nature of the airline industry. That is, the country consists of mostly regional airports that connect through more central hubs for longer distance flights.

## Add state and region vertex vertex

To help visualize the network, it makes sense to map airports to states and regions.

```{r}
region_map <- read.csv("states.csv", header = T)
net1 %v% "state" <- as.character(sapply(strsplit(get.vertex.attribute(net1, "City"), ", ", fixed = TRUE), function(x) x[2]))
lookup_table <- join(region_map, data.frame("State.Code" = get.vertex.attribute(net1, "state")), "State.Code")
net1 %v% "region" <- as.character(sapply(get.vertex.attribute(net1, "state"), function(x) as.character(lookup_table[match(x, as.character(lookup_table[,1])),2])))
```

## Examine complete network

```{r}
set.seed(30)
net2 <- symmetrize(net1)
gplot(net2, vertex.col = 2, displaylabels = FALSE)
```

The network is hard to intelligbly decipher at 8.2k edges. Nonetheless, several communities are visible with obvious central nodes.

## Calculate centrality

In order to produce a more meaningful visualization, we first need to get a better sense of the most central nodes, i.e., we need to calculate centrality measures: degree and betweenness. 

```{r}
# add vertex attributes for each centrality measure
net1 %v% "degree" <- degree(net1)
net1 %v% "btw" <- betweenness(net1)

# view summary of centrality attributes
summary(get.vertex.attribute(net1, "degree"))
summary(get.vertex.attribute(net1, "btw"))
```

## Prepare sub-network for visualization

Next we will create two sub-networks:

* Sub-network 1: represents the states of the top-10 airports as sorted by degree
* Sub-network 2: represents the states of the top-10 airports as sorted by betweenness

```{r}
top_states <- function(n, net, centrality) {
  sorted_deg <- sort(get.vertex.attribute(net, centrality), index.return=TRUE)
  top_x = rev(sorted_deg$ix)[1:n]
  states <- get.vertex.attribute(net, "state")
  states_tx <- unique(states[top_x])
  return(states_tx)
}

top_10_deg <- top_states(10, net1, "degree")
top_10_btw <- top_states(10, net1, "btw")
sub1 <- get.inducedSubgraph(net1, which(net1 %v% "state" %in% top_10_deg))
sub2 <- get.inducedSubgraph(net1, which(net1 %v% "state" %in% top_10_btw))
```

## Plot sub-networks

```{r message=FALSE, warning=FALSE}
set.seed(30)

op <- par(mar = c(0,0,1,0),mfrow=c(1,2))

ggnet2(sub1, mode="kamadakawai",
      label.size = 2.1,
      label.alpha = 0.75,
      label = "name",
      label.color = "white",
      color="state",
      color.legend = "State",
      size = "degree",
      size.min = 2,
      palette = "Set1") + 
  guides(size = FALSE) +
  theme(panel.background = element_rect(fill = "grey15")) +
  ggtitle("Airport Network", subtitle="Node size signifies degree centrality")

ggnet2(sub2, mode="kamadakawai",
      label.size = 2.1,
      label.alpha = 0.75,
      label = "name",
      label.color = "white",
      color="state",
      color.legend = "State",
      size = "degree",
      size.min = 2,
      palette = "Set1") + 
  guides(size = FALSE) +
  theme(panel.background = element_rect(fill = "grey15")) +
  ggtitle("Airport Network", subtitle="Node size signifies betweenness centrality")

par(op)
```

The difference in these 2 networks is what makes them interesting. Specifically, the first network contains the top-10 states as measured by airport **degree** centrality. The 2nd network contains the top-10 states as measured by airport **betweenness** centrality. The *node size* in both visualizations reflects airport degree centrality. Therefore:

* The first visualization presents the most central/important airports by number of direct connections. 
* The second visualization presents the most central/important airports by number of indirect connections. 
* So the first visualization is an absolute importance visualization, while the second visualization is a relative importance visualization.

For example, in the first visualization - airports such as LAX, SFO, DEN, and LAS are among the biggest hubs with the *most direct* connections in the country. So they have the highest degrees. Compare this to the second visualization, which shows many of the largest nodes (and most numerous) as being from Alaska. This is because Alaska is a huge state with many small/regional airports that depend on a handful of hubs for interstate and international flights. So in the 2nd visualization, Alaska's hub airports (ANC, FAI, BET, OTZ) have *at least* equal degree centrality as LAX, PHX, DEN, etc.

# Community Detection

## Select sample of full network for plotting

```{r message=FALSE, warning=FALSE}
library(igraph)
set.seed(30)
total_airports <- length(V(full_net)$name)
half_airports = round(total_airports/2)
sample_airports <- sample(seq(1:total_airports),half_airports, replace = F)
subnet <- induced_subgraph(full_net, vids=V(full_net)[sample_airports])
subnet <- simplify(subnet)
subnet <- as.undirected(subnet)
```

## Algorithm testing and modularity

```{r}
cw1 <- cluster_leading_eigen(subnet)
cw2 <- cluster_fast_greedy(subnet)
cw3 <- cluster_louvain(subnet)
print(modularity(cw1))
print(modularity(cw2))
print(modularity(cw3))
```

Out of the 3 community detection algorithms tested above, the one with the highest modularity is the third ("Louvain"). However, all 3 community detection algorithms post a similar modularity between 0.38 and nearly 0.40. This implies that they all detect considerable clustering with respect to node groupings in the network ^[1]^ (p.115, Network Analysis in R).

## Plot communities

```{r}
op <- par(mar = c(0,0,4,0),mfrow=c(1,3))
plot(cw1, subnet,
     vertex.label = NA,
     vertex.size=4,
     edge.arrow.size = 0)

plot(cw2, subnet,
     vertex.label = NA,
     vertex.size=4,
     edge.arrow.size = 0)

plot(cw3, subnet,
     vertex.label = NA,
     vertex.size=4,
     edge.arrow.size = 0)

par(op)
```

## View community membership
```{r}

```


# Network modeling


